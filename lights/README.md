# Brief Documentation

>[Disclaimer] Generated by Gemini 2.5 Flash

> Yay LLM thinks my code is well-structured ðŸ¤£

This Arduino C++ code is for a **wireless smart bicycle light system**. It uses an ESP32 microcontroller, a NeoPixel LED strip, and an MPU6050 accelerometer/gyroscope. The system is designed to act as a **receiver** that controls the lights based on incoming wireless signals and sensor data.

Here's a breakdown of its key components and functionalities:

---

### Key Components

* **ESP-NOW:** The code uses the ESP-NOW protocol for wireless communication between two ESP32 devices. One device likely acts as a **transmitter** (e.g., a device with a button on the handlebars), and this device acts as a **receiver** (or a dual-role device) mounted on the bike's rear.
* **NeoPixel LED Strip:** The `Adafruit_NeoPixel` library controls a ring of 12 RGB LEDs. These are used to display various signals, such as turn signals and brake lights.
* **MPU6050 Sensor:** The `Adafruit_MPU6050` library interfaces with an Inertial Measurement Unit (IMU). The code specifically uses the gyroscope to detect **angular rotation**, which is used to determine if the bicycle is turning.
* **NoDelay Library:** This library is used to manage timing without using the blocking `delay()` function. This is crucial for a real-time system that needs to perform multiple tasks simultaneously, such as reading sensors and updating LEDs.

---

### Core Functionality

#### 1. Wireless Communication (`ESP-NOW`)

The code sets up an ESP-NOW peer-to-peer connection. It defines a `struct_message_in` to receive incoming signals and a `struct_message_out` to send status updates.

* `OnDataRecv()`: This function is a **callback** that is triggered when a wireless message is received. It reads an integer value from the incoming data, which represents a `signalState`: `-1` (OFF), `0` (LEFT), `1` (RIGHT), or `2` (Power Saving). The `buttonEventHandler()` is then called to act on this signal.
* `OnDataSent()`: This callback reports on the success or failure of a sent message.
* `esp_now_send()`: The code sends status updates (the current `signalState` and `ledIndex`) to the transmitter device, likely to provide feedback on the current lighting status.

#### 2. Turn Signal Logic (`trackRotation()`)

This is one of the most complex parts of the code. The system doesn't just rely on a button press to turn off the signal. It uses the gyroscope to detect when a turn has been **completed**.

* `detectTurn()`: This function uses the gyroscope's Y-axis data to detect a sustained rotation above a certain `initialRotation` threshold for a specified `initialDuration`. This prevents accidental triggers from small movements.
* `trackRotation()`: Once a turn is detected, this function starts **integrating the angular velocity** from the gyroscope over time to calculate the `cumulativeAngle` of the turn. It then checks if this cumulative angle exceeds a `minAngle` (60 degrees).
* `detectTurnEnd()`: After the `minAngle` is reached, this function starts averaging the gyroscope data again. If the average rotation drops below the `turnEndThres` (0.07) for a `turnEndDuration` (2500 ms), it's assumed the turn has ended.
* `clearSignal()`: When a turn is completed, this function is called to turn off the LEDs and reset the tracking variables. This provides an **automatic turn signal cancellation** feature.

#### 3. Light Control (`executeLeftSignal()` and `executeRightSignal()`)

These functions manage the visual turn signals. They use the `noDelay` library to create a non-blocking blinking effect.

* They are called repeatedly within the `loop()` function as long as `signalState` is `0` (left) or `1` (right).
* The `ledIndex` variable is used to alternate between turning the lights on and off, creating a blinking pattern.
* `executeRightSignal()` lights up the right half of the LED ring (LEDs 6 to 11 and LED 0).
* `executeLeftSignal()` lights up the left half (LEDs 0 to 6).

#### 4. State Management

* **`signalState`**: A global variable that controls the main state of the system: `-1` (OFF), `0` (LEFT), or `1` (RIGHT).
* **`powerSaving`**: A `boolean` variable that is toggled by the `signalState == 2` message. When true, the system enters a power-saving mode by clearing the lights and possibly preparing to enter deep sleep (though the sleep functions are commented out).
* **`signalTimeoutCounter`**: A simple counter that increments each time the turn signal blinks. If it exceeds a `signalTimeoutThres` (100 blinks), it automatically cancels the signal, acting as a failsafe.

---

### What's Missing or Commented Out?

* **Braking Logic:** A significant portion of the code related to braking detection (`detectBrake()` and related variables) is commented out. This logic was intended to use the accelerometer data (`aevent.acceleration.y` and `aevent.acceleration.z`) to detect deceleration. It also included a rotation matrix calculation to account for the angle of the sensor. This feature is not currently active.
* **AHRS (Attitude and Heading Reference System):** The code includes commented-out lines for an AHRS filter (`Adafruit_Madgwick`). This would have been used for more accurate orientation tracking (roll, pitch, yaw) and would have provided a more robust way to detect a bike's lean or tilt, which is often a better indicator of turning than just angular velocity.
* **Serial Communication:** Many `Serial.print()` and `Serial.println()` statements are commented out. These are very useful for debugging and would show the sensor data and state changes in real-time.

Overall, this is a well-structured and functional prototype for an intelligent bicycle light system, with a clear focus on **automatic turn signal cancellation** and wireless communication. The commented-out code suggests it's an ongoing project with potential for more advanced features like automatic braking detection.
